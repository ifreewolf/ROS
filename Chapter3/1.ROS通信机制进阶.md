# 第三章 ROS通信机制进阶

上一章内容，主要介绍了ROS通信的实现，内容偏向于粗粒度的通信框架的讲解，没有详细介绍涉及的API，也没有封装代码，鉴于此，本章主要内容如下:

- ROS常用API介绍；
- ROS中自定义头文件与源文件的使用。

预期达成的学习目标:

- 熟练掌握ROS常用API；
- 掌握ROS中自定义头文件与源文件的配置。

## 3.1 常用API

- ROS节点的初始化相关API;
- NodeHandle的基本使用相关API;
- 话题的发布方，订阅方对象相关API;
- 服务的服务端，客户端对象相关API;
- 时间相关API;
- 日志输出相关API。

### 3.1.1 初始化
----

<B>C++</B>

```cpp
#include "ros/ros.h"

/**
 * 作用：ROS初始化函数
 * 
 * 参数：
 *  1. argc     ---- 参数个数（n+1）
 *  2. argv     ---- 封装参数的数组
 *  3. name     ---- 为节点命名(唯一性)
 *  4. options
 * 
 * 使用：
 *  1. argc 与 argv 的使用
 *      如果按照ROS中的特定格式传入实参，那么ROS可以加以使用，比如用来设置全局参数、给节点重命名...
 *  2. options 的使用
 *      节点名称需要保证唯一，会导致一个问题：同一个节点不能重复启动。
 *      结果：ROS 中当有重名的节点启动时，之前的节点会被关闭。
 *      需求：特定场景下，需要一个节点多次启动且能正常运行，怎么办？
 *      解决：设置启动项 ros::init_options::AnonymousName
 *          当创建ROS节点时，会在用户自定义的节点名称后缀随机数，从而避免重名问题。
 *      
 * 
 * 函数原型：
 * void init(int &argc, char **argv, const std::string& name, uint32_t options = 0);
*/

int main(int argc, char *argv[])
{

    ros::init(argc, argv, "init_api", ros::init_options::AnonymousName);
    ros::NodeHandle nh;

    int count = 0;
    ros::Rate rate(1);
    while (ros::ok())
    {
        ROS_INFO("%s node is running ---- %d", ros::this_node::getName().c_str(), count);
        count++;
        rate.sleep();
    }    
    
    return 0;
}
```

>argc和argv如果按照ROS中的特定格式传入实参，那么ROS可以加以使用，比如用来设置全局参数、给节点重命名。

使用`rosrun plumbing_api init_api _length:=2` 可以给这个node创建一个全局变量：length

```shell
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosrun plumbing_api demo01_init_api _length:=2
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosparam list
/init_api/length        # 这个就是初始化启动添加的全局变量，其中/init_api是node的命名。
/rosdistro
/roslaunch/uris/host_fgs_ms_7d17__38261
/rosversion
/run_id

fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosparam get /init_api/length    # 可以获取
2
```

>节点名称需要保证唯一，会导致一个问题：同一个节点不能重复启动。ROS中当有重名的节点启动时，之前的节点会被关闭。
参数options可以解决这个问题，将options设置为`ros::init_options::AnonymousNmae`即可在每个启动的节点名称后面加上时间后缀，可以让一个节点重复启动。

未添加options前：

```shell
[ INFO] [1690990277.051701363]: /init_api node is running ---- 6
[ WARN] [1690990277.274786557]: Shutdown request received.
[ WARN] [1690990277.274874254]: Reason given for shutdown: [[/init_api] Reason: new node registered with same name]
```

给options添加设置后，同一个节点可以被多次启动。

```shell
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosnode list
/init_api_1690990405013105385 # 节点1，后跟时间戳
/init_api_1690990409531076982 # 节点2，后跟时间戳
/rosout
```



<B>Python</B>

```python
def init_node(name, argv=None, anonymous=False, log_level=None, disable_rostime=False, disable_rosout=False, disable_signals=False, xmlrpc_port=0, tcpros_port=0):
    """
    在ROS msater中注册节点

    @param name: 节点名称，必须保证节点名称唯一，节点名称中不能使用命名空间(不能包含 '/')
    @type  name: str

    @param anonymous: 取值为 true 时，为节点名称后缀随机编号
    @type anonymous: bool
    """
```


### 3.1.2 话题与服务相关对象
----

<B>C++</B>

在roscpp中，话题和服务的相关对象一般由NodeHandle创建。

NodeHandle有一个重要作用是可以用于设置命名空间，这是后期的重点。

<B>1. 发布对象</B>

<B>对象获取：</B>

```cpp
#include "ros/ros.h"
#include "std_msgs/String.h"

int main(int argc, char *argv[])
{
    setlocale(LC_ALL, "");

    ros::init(argc, argv, "pub_api");

    ros::NodeHandle nh;

    /**
     * 作用：创建发布者对象  
     * 
     * 模板：被发布的消息的类型
     * 
     * 参数：
     *      1.话题名称
     *      2.队列长度
     *      3.latch(可选) 如果设置为true，会保存发布方的最后一条消息，并且新的订阅对象连接到发布方时，发布方会将这条消息发送给订阅者。
     * 
     * 使用：
     *      latch 设置为true的作用？
     *      以静态地图发布为例，方案1：可以使用固定频率发送地图数据，但是效率低；方案2：可以将地图发布对象的latch设置为true，并且发布方只发送一次数据，每当订阅者连接时，将地图数据发送给订阅者(只发送一次)，这样提高了数据的发送效率。
     * 
     * 函数原型：
     *  template<class M>
     *  Publisher advertise(const std::string& topic, uint32_t queue_size, bool latch=false);
    */
    ros::Publisher pub = nh.advertise<std_msgs::String>("test_pub_api", 10, true);

    std_msgs::String msg;

    ros::Rate rate(1);

    int count = 0;

    while (ros::ok())
    {
        std::stringstream ss;

        ss << "hello ----> " << count;
        msg.data = ss.str();

        if (count < 10) {
            pub.publish(msg);
            ROS_INFO("发布的数据是：%s", ss.str().c_str());
        }

        rate.sleep(); 

        ros::spinOnce();

        count++;    
    }

    return 0;
}
```

这里主要对`nh.advertise()`函数的latch进行说明。

>当latch使用默认的false时，该程序在发完前面10个数据后，就不会再发送数据，并且订阅方也接收不到数。当latch设置为true时，该程序在发完前面10个数据后不再发送数据，但是当有新的订阅方连接发布方时，会将最后一个数据发给订阅方。

```shell
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosrun plumbing_api demo02_pub_api 
[ INFO] [1691075672.341054629]: 发布的数据是：hello ----> 0
[ INFO] [1691075673.341208217]: 发布的数据是：hello ----> 1
[ INFO] [1691075674.341208764]: 发布的数据是：hello ----> 2
[ INFO] [1691075675.341214282]: 发布的数据是：hello ----> 3
[ INFO] [1691075676.341194941]: 发布的数据是：hello ----> 4
[ INFO] [1691075677.341193029]: 发布的数据是：hello ----> 5
[ INFO] [1691075678.341214947]: 发布的数据是：hello ----> 6
[ INFO] [1691075679.341209759]: 发布的数据是：hello ----> 7
[ INFO] [1691075680.341210700]: 发布的数据是：hello ----> 8
[ INFO] [1691075681.341209264]: 发布的数据是：hello ----> 9


fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rostopic echo /test_pub_api 
data: "hello ----> 9"
---
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rostopic echo /test_pub_api 
data: "hello ----> 9"
---
# 连续两次订阅，都接收到发布方的最后一个数据。
```


### 3.1.3 回旋函数
-----

<B>C++</B>

在ROS程序中，频繁的使用了`ros::spin()` 和 `ros::spinOnce()` 两个回旋函数，可以用于处理回调函数。

<B>1.spinOnce()</B>

```cpp
/**
 * \brief 处理一轮回调
 * 
 * 一般应用场景：
 *      在循环体内，处理所有可用的回调函数
 *
 */
ROSCPP_DECL void spinOnce();
```

<B>2.spin()</B>

```cpp
/**
 * \brief 进入循环处理回调
*/
ROSCPP_DECL void spin();
```

<B>3.两者比较</B>

<B>相同点：</B>二者都用于处理回调函数；

<B>不同点：</B>`ros::spin()`是进入了循环执行回调函数，而`ros::spinOnce()`只会执行一次回调函数(没有循环)，在`ros::spin()`后的语句不会执行到，而`ros::spinOnce()`后的语句可以执行。



### 3.1.4 时间

ROS中时间相关的API是及其常用，比如：获取当前时刻、持续时间的设置、执行频率、休眠、定时器...都与时间相关。

---

<B>C++</B>

<B>1. 时刻</B>

获取时刻，或是设置指定时刻

```cpp
#include "ros/ros.h"

/**
 * 需求：演示时间相关操作（获取当前时刻 + 设置指定时刻）
 * 实现：
 *      1.准备（头文件、节点初始化、NodeHandle创建...）
 *      2.获取当前时间
 *      3.设置指定时刻
*/


int main(int argc, char *argv[])
{
    setlocale(LC_ALL, "");

    // 1.准备（头文件、节点初始化、NodeHandle创建...）
    ros::init(argc, argv, "hello_time");
    ros::NodeHandle nh; // 必须创建句柄，否则时间没有初始化，导致后续API调用失败。

    // 2.获取当前时间
    // now 函数会将当前时刻封装并返回
    // 当前时刻：now 被调用执行的那一刻
    // 参考系：1970年01月01日 00:00:00
    ros::Time right_now = ros::Time::now(); // 将当前时刻封装成对象
    ROS_INFO("当前时刻：%.2f", right_now.toSec());  // 获取距离 1970年01月01日 00：00：00的秒数，返回double类型
    ROS_INFO("当前时刻：%d", right_now.sec);  // 获取距离 1970年01月01日 00:00:00 的秒数，返回整形

    ros::Time someTime(100, 100000000); // 参数1：秒数， 参数2:纳秒
    ROS_INFO("时刻：%.2f", someTime.toSec());   //  100.10

    ros::Time someTime2(100.3); // 直接传入 double 类型的秒数
    ROS_INFO("时刻：%.2f", someTime2.toSec());  // 100.30
    
    return 0;
}
```

<B>2. 持续时间</B>

设置一个时间区间(间隔)：

```cpp
ROS_INFO("开始休眠:%.2f", ros::Time::now().toSec());
ros::Duration du(4.5);  // 持续时间4.5s

du.sleep(); // 睡眠4.5秒
ROS_INFO("休眠结束:%.2f", ros::Time::now().toSec());

输出结果：
[ INFO] [1691334907.013598317]: 开始休眠:1691334907.01
[ INFO] [1691334911.513804863]: 休眠结束:1691334911.51
```

<B>3. 持续时间与时刻运算</B>

为了方便使用，ROS中提供了时间与时刻的运算：

```cpp
/*
 * 需求3：已知程序开始运行的时刻和程序运行的时间，求运行结果的时刻。
 * 实现：
 *      1.开始执行的时刻
 *      2.模拟运行时间
 *      3.计算结束时刻 = 开始 - 持续时间
 * 注意：
 *      1.时刻与持续时间可以执行加减
 *      2.持续时间之间也可以执行加减
 *      3.时刻之间只可以相减，不能相加
*/
ROS_INFO("-----------------------时间运算---------------------");
// 时刻与持续时间运算
// 1.开始执行的时刻
ros::Time begin = ros::Time::now();
// 2.模拟运行时间
ros::Duration du1(5);
// 3.计算结束时刻 = 开始 + 持续时间
ros::Time stop = begin + du1;
ROS_INFO("开始时刻：%.2f", begin.toSec());
ROS_INFO("结束时刻：%.2f", stop.toSec());

// 时刻与时刻运算
// ros::Time sum = begin + stop; //    不可以相加
ros::Duration du2 = begin - stop;   // 返回ros::Duration类型，表示持续时间
ROS_INFO("时刻相减：%.2f", du2.toSec());

// 持续时间与持续时间的运算
ros::Duration du3 = du1 + du2;  // 0
ros::Duration du4 = du1 - du2;  // 10
ROS_INFO("du1 + du2 = %.2f", du3.toSec());
ROS_INFO("du1 - du2 = %.2f", du4.toSec());


// 计算结果：
[ INFO] [1691335848.559259787]: -----------------------时间运算---------------------
[ INFO] [1691335848.559310770]: 开始时刻：1691335848.56
[ INFO] [1691335848.559360966]: 结束时刻：1691335853.56
[ INFO] [1691335848.559393464]: 时刻相减：-5.00
[ INFO] [1691335848.559425042]: du1 + du2 = 0.00
[ INFO] [1691335848.559454475]: du1 - du2 = 10.00
```

<B>4. 设置运行频率</B>

```cpp
ros::Rate rate(1);  // 指定频率

while (true)
{
    ROS_INFO("---------------code--------------");
    rate.sleep(); // 休眠，休眠时间 = 1 / 频率
}
```

<B>5. 定时器</B>

ROS中内置了专门的定时器，可以实现与ros::Rate类似的效果：

```cpp
/*
 * 需求4：每隔1秒钟，在控制台输出一段文本
 * 实现：
 *      策略1：ros::Rate()
 *      策略2：定时器
 * 注意：
 *      创建：nh.createTimer()
 *      参数1：时间间隔
 *      参数2：回调函数（时间事件 TimerEvent）
 *      参数3：是否只执行一次
 *      参数4：是否自动启动（当设置为false时，需要手动调用 timer.start()）
 * 
 *      定时器启动后：ros::spin()，因为需要回调函数
*/

// 回调函数
void cb(const ros::TimerEvent& event)
{
    ROS_INFO("-------------------");
    ROS_INFO("函数被调用的时刻：%.2f", event.current_real.toSec());
}

//-----------------------------------------------------------
ROS_INFO("-----------------------定时器---------------------");

/**
 *  ros::Timer createTimer(ros::Duration period,    // 时间间隔 ---- 1s
 *          const ros::TimerCallback &callback,     // 回调函数 ---- 封装业务
 *          bool oneshot = false,                   // 是否是一次性
 *          bool autostart = true)                  // 自动启动，默认为true
 * 
*/
// ros::Timer timer = nh.createTimer(ros::Duration(1), cb); // 简单的实现
// ros::Timer timer = nh.createTimer(ros::Duration(1), cb, true);  // 只启动一次,执行一次后程序等待
ros::Timer timer = nh.createTimer(ros::Duration(1), cb, false, false);  // 不自动启动
timer.start();  // 手动启动

ros::spin();    // 需要回旋
```


### 3.1.5 其他函数

在发布实现时，一般会循环发布消息，循环的判断条件一般由节点状态来控制，C++中可以通过ros::ok()来判断节点状态是否正常，而python中则通过rospy.is_shutdown()来实现判断，导致节点退出的原因主要有如下几种：

- 节点接收到了关闭信息，比如常用的`ctrl+c`快捷键就是关闭节点的信号；
- 同名节点启动，导致现有节点退出；
- 程序中的其他部分调用了节点关闭相关的API(C++中是ros::shutdown()，python中是rospy.signal_shutdown())

另外，日志相关的函数也是及其常用的，在ROS中日志被划分为如下级别：

- DEBUG(调试)：只在调试时使用，此类消息不会输出到控制台；
- INFO(信息)：标准消息，一般用于说明系统内正在执行的操作；
- WARN(警告)：提醒一些异常情况，但程序仍然可以执行；
- ERROR(错误)：提示错误信息，此类错误会影响程序运行；
- FATAL(严重错误)：此类错误将阻止节点继续运行。

#### C++

1.节点状态判断

```cpp
/**
 * 检查节点是否已经退出
 * 
 * ros::shutdown() 被调用且执行完毕后，该函数将会返回 false
 * 
 * return true 如果节点还健在，false 如果节点已经火化了
 */

bool ok();
```

2. 节点关闭函数

```cpp
/**
 * 关闭节点
*/
void shutdown();
```

3. 日志函数

使用示例

```cpp
ROS_DEBUG("hello,DEBUG");   // 不会输出
ROS_INFO("hello,INFO");     // 默认白色字体
ROS_WARN("hello,WARN");     // 默认黄色字体
ROS_ERROR("hello,ERROR");   // 默认红色字体
ROS_FATAL("hello,FATAL");   // 默认红色字体
```
---

#### Python
