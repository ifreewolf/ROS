# 第三章 ROS通信机制进阶

上一章内容，主要介绍了ROS通信的实现，内容偏向于粗粒度的通信框架的讲解，没有详细介绍涉及的API，也没有封装代码，鉴于此，本章主要内容如下:

- ROS常用API介绍；
- ROS中自定义头文件与源文件的使用。

预期达成的学习目标:

- 熟练掌握ROS常用API；
- 掌握ROS中自定义头文件与源文件的配置。

## 3.1 常用API

- ROS节点的初始化相关API;
- NodeHandle的基本使用相关API;
- 话题的发布方，订阅方对象相关API;
- 服务的服务端，客户端对象相关API;
- 时间相关API;
- 日志输出相关API。

### 3.1.1 初始化
----

<B>C++</B>

```cpp
#include "ros/ros.h"

/**
 * 作用：ROS初始化函数
 * 
 * 参数：
 *  1. argc     ---- 参数个数（n+1）
 *  2. argv     ---- 封装参数的数组
 *  3. name     ---- 为节点命名(唯一性)
 *  4. options
 * 
 * 使用：
 *  1. argc 与 argv 的使用
 *      如果按照ROS中的特定格式传入实参，那么ROS可以加以使用，比如用来设置全局参数、给节点重命名...
 *  2. options 的使用
 *      节点名称需要保证唯一，会导致一个问题：同一个节点不能重复启动。
 *      结果：ROS 中当有重名的节点启动时，之前的节点会被关闭。
 *      需求：特定场景下，需要一个节点多次启动且能正常运行，怎么办？
 *      解决：设置启动项 ros::init_options::AnonymousName
 *          当创建ROS节点时，会在用户自定义的节点名称后缀随机数，从而避免重名问题。
 *      
 * 
 * 函数原型：
 * void init(int &argc, char **argv, const std::string& name, uint32_t options = 0);
*/

int main(int argc, char *argv[])
{

    ros::init(argc, argv, "init_api", ros::init_options::AnonymousName);
    ros::NodeHandle nh;

    int count = 0;
    ros::Rate rate(1);
    while (ros::ok())
    {
        ROS_INFO("%s node is running ---- %d", ros::this_node::getName().c_str(), count);
        count++;
        rate.sleep();
    }    
    
    return 0;
}
```

>argc和argv如果按照ROS中的特定格式传入实参，那么ROS可以加以使用，比如用来设置全局参数、给节点重命名。

使用`rosrun plumbing_api init_api _length:=2` 可以给这个node创建一个全局变量：length

```shell
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosrun plumbing_api demo01_init_api _length:=2
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosparam list
/init_api/length        # 这个就是初始化启动添加的全局变量，其中/init_api是node的命名。
/rosdistro
/roslaunch/uris/host_fgs_ms_7d17__38261
/rosversion
/run_id

fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosparam get /init_api/length    # 可以获取
2
```

>节点名称需要保证唯一，会导致一个问题：同一个节点不能重复启动。ROS中当有重名的节点启动时，之前的节点会被关闭。
参数options可以解决这个问题，将options设置为`ros::init_options::AnonymousNmae`即可在每个启动的节点名称后面加上时间后缀，可以让一个节点重复启动。

未添加options前：

```shell
[ INFO] [1690990277.051701363]: /init_api node is running ---- 6
[ WARN] [1690990277.274786557]: Shutdown request received.
[ WARN] [1690990277.274874254]: Reason given for shutdown: [[/init_api] Reason: new node registered with same name]
```

给options添加设置后，同一个节点可以被多次启动。

```shell
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosnode list
/init_api_1690990405013105385 # 节点1，后跟时间戳
/init_api_1690990409531076982 # 节点2，后跟时间戳
/rosout
```



<B>Python</B>

```python
def init_node(name, argv=None, anonymous=False, log_level=None, disable_rostime=False, disable_rosout=False, disable_signals=False, xmlrpc_port=0, tcpros_port=0):
    """
    在ROS msater中注册节点

    @param name: 节点名称，必须保证节点名称唯一，节点名称中不能使用命名空间(不能包含 '/')
    @type  name: str

    @param anonymous: 取值为 true 时，为节点名称后缀随机编号
    @type anonymous: bool
    """
```


### 3.1.2 话题与服务相关对象
----

<B>C++</B>

在roscpp中，话题和服务的相关对象一般由NodeHandle创建。

NodeHandle有一个重要作用是可以用于设置命名空间，这是后期的重点。

<B>1. 发布对象</B>

<B>对象获取：</B>

```cpp
#include "ros/ros.h"
#include "std_msgs/String.h"

int main(int argc, char *argv[])
{
    setlocale(LC_ALL, "");

    ros::init(argc, argv, "pub_api");

    ros::NodeHandle nh;

    /**
     * 作用：创建发布者对象  
     * 
     * 模板：被发布的消息的类型
     * 
     * 参数：
     *      1.话题名称
     *      2.队列长度
     *      3.latch(可选) 如果设置为true，会保存发布方的最后一条消息，并且新的订阅对象连接到发布方时，发布方会将这条消息发送给订阅者。
     * 
     * 使用：
     *      latch 设置为true的作用？
     *      以静态地图发布为例，方案1：可以使用固定频率发送地图数据，但是效率低；方案2：可以将地图发布对象的latch设置为true，并且发布方只发送一次数据，每当订阅者连接时，将地图数据发送给订阅者(只发送一次)，这样提高了数据的发送效率。
     * 
     * 函数原型：
     *  template<class M>
     *  Publisher advertise(const std::string& topic, uint32_t queue_size, bool latch=false);
    */
    ros::Publisher pub = nh.advertise<std_msgs::String>("test_pub_api", 10, true);

    std_msgs::String msg;

    ros::Rate rate(1);

    int count = 0;

    while (ros::ok())
    {
        std::stringstream ss;

        ss << "hello ----> " << count;
        msg.data = ss.str();

        if (count < 10) {
            pub.publish(msg);
            ROS_INFO("发布的数据是：%s", ss.str().c_str());
        }

        rate.sleep(); 

        ros::spinOnce();

        count++;    
    }

    return 0;
}
```

这里主要对`nh.advertise()`函数的latch进行说明。

>当latch使用默认的false时，该程序在发完前面10个数据后，就不会再发送数据，并且订阅方也接收不到数。当latch设置为true时，该程序在发完前面10个数据后不再发送数据，但是当有新的订阅方连接发布方时，会将最后一个数据发给订阅方。

```shell
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rosrun plumbing_api demo02_pub_api 
[ INFO] [1691075672.341054629]: 发布的数据是：hello ----> 0
[ INFO] [1691075673.341208217]: 发布的数据是：hello ----> 1
[ INFO] [1691075674.341208764]: 发布的数据是：hello ----> 2
[ INFO] [1691075675.341214282]: 发布的数据是：hello ----> 3
[ INFO] [1691075676.341194941]: 发布的数据是：hello ----> 4
[ INFO] [1691075677.341193029]: 发布的数据是：hello ----> 5
[ INFO] [1691075678.341214947]: 发布的数据是：hello ----> 6
[ INFO] [1691075679.341209759]: 发布的数据是：hello ----> 7
[ INFO] [1691075680.341210700]: 发布的数据是：hello ----> 8
[ INFO] [1691075681.341209264]: 发布的数据是：hello ----> 9


fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rostopic echo /test_pub_api 
data: "hello ----> 9"
---
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter3/demo04_ws$ rostopic echo /test_pub_api 
data: "hello ----> 9"
---
# 连续两次订阅，都接收到发布方的最后一个数据。
```


### 3.1.3 回旋函数
-----

<B>C++</B>

在ROS程序中，频繁的使用了`ros::spin()` 和 `ros::spinOnce()` 两个回旋函数，可以用于处理回调函数。

<B>1.spinOnce()</B>

```cpp
/**
 * \brief 处理一轮回调
 * 
 * 一般应用场景：
 *      在循环体内，处理所有可用的回调函数
 *
 */
ROSCPP_DECL void spinOnce();
```

<B>2.spin()</B>

```cpp
/**
 * \brief 进入循环处理回调
*/
ROSCPP_DECL void spin();
```

<B>3.两者比较</B>

<B>相同点：</B>二者都用于处理回调函数；

<B>不同点：</B>`ros::spin()`是进入了循环执行回调函数，而`ros::spinOnce()`只会执行一次回调函数(没有循环)，在`ros::spin()`后的语句不会执行到，而`ros::spinOnce()`后的语句可以执行。