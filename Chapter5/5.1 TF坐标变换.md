# 5.1 TF坐标变换

机器人系统上，有多个传感器，如激光雷达、摄像头等，有的传感器是可以感知机器人周边的物体方位(或者称之为:坐标，横向、纵向、高度的距离信息)的，以协助机器人定位障碍物，可以直接将物体相对该传感器的方位信息，等价于物体相对于机器人系统或机器人其它组件的方位信息吗？显然是不行的，这中间需要一个转换过程。更具体描述如下:

>场景1:雷达与小车
>
>现有一移动式机器人底盘，在底盘上安装了一雷达，雷达相对于底盘的偏移量已知，现雷达检测到一障碍物信息，获取到坐标分别为(x,y,z)，该坐标是以雷达为参考系的，如何将这个坐标转换成以小车为参考系的坐标呢？

<div align="center">
    <img src="./image/10TF01.png" />
    <img src="./image/11TF02.png" />
</div>

>场景2:现有一带机械臂的机器人(比如:PR2)需要夹取目标物，当前机器人头部摄像头可以探测到目标物的坐标(x,y,z)，不过该坐标是以摄像头为参考系的，而实际操作目标物的是机械臂的夹具，当前我们需要将该坐标转换成相对于机械臂夹具的坐标，这个过程如何实现？

<div align="center">
    <img src="./image/PR2坐标变换.png" />
</div>

当然，根据我们高中学习的知识，在明确了不同坐标系之间的的相对关系，就可以实现任何坐标点在不同坐标系之间的转换，但是该计算实现是较为常用的，且算法也有点复杂，因此在 ROS 中直接封装了相关的模块: 坐标变换(TF)。

---

<B>概念</B>

<B>TF:</B>TransForm Frame， 坐标变换

<B>坐标系：</B>ROS中是通过坐标系来标定物体的，确切的是通过右手坐标系来标定的。

<div align="center">
    <img src="./image/右手坐标系.jpg" />
</div>

<B>作用</B>

在ROS中用于实现不同坐标系之间的点或向量的转换。

<B>案例</B>

<B>小乌龟跟随案例：</B>如本章引言部分演示。

<B>说明</B>

在ROS中坐标变换最初对应的是tf，不过在hydro版本开始，tf被弃用，迁移到tf2，后者更为简洁高效，tf2对应得常用功能包有：

tf2_geometry_msgs:可以将ROS消息转换成tf2消息。

tf2：封装了坐标变换的常用消息。

tf2_ros:为tf2提供了roscpp和rospy绑定，封装了坐标变换常用的API。

---



## 5.1.1 坐标msg消息

订阅发布模型中数据载体msg是一个重要实现，首先需要了解一下，在坐标转换实现中常用的msg:`geometry_msgs/TransformStamped`和`geometry_msgs/PointStamped`

前者用于传输坐标系相关位置信息，后者用于传输某个坐标系内坐标点的信息。在坐标变换中，频繁的需要使用到坐标系的相对关系以及坐标点信息。

### 1. geometry_msgs/TransformStamped

命令行键入：`rosmsg info geometry_msgs/TransformStamped`

```bash
std_msgs/Header header              # 头信息
  uint32 seq                            # |-- 序列号
  time stamp                            # |-- 时间戳
  string frame_id                       # |-- 坐标ID
string child_frame_id               # 子坐标系的id
geometry_msgs/Transform transform   # 坐标信息
  geometry_msgs/Vector3 translation     # |-- 偏移量
    float64 x                               # |-- X 方向的偏移量
    float64 y                               # |-- Y 方向的偏移量
    float64 z                               # |-- Z 方向的偏移量
  geometry_msgs/Quaternion rotation     # |-- 四元数
    float64 x
    float64 y
    float64 z
    float64 w
```

四元数用于表示坐标的相对姿态。


### 2. geometry_msgs/PointStamped

命令行键入：`rosmsg info geometry_msgs/PointStamped`

```bash
std_msgs/Header header      # 头
  uint32 seq                    # |-- 序号
  time stamp                    # |-- 时间戳
  string frame_id               # |-- 所属坐标系的id
geometry_msgs/Point point   # 点坐标
  float64 x                     # |-- x y z 坐标
  float64 y
  float64 z
```

---


## 5.1.2 静态坐标变换

所谓静态坐标变换，是指两个坐标系之间的相对位置是固定的。

<B>需求描述：</B>

现有一机器人模型，核心构成包含主体与雷达，各对应一坐标系，坐标系的原点分别位于主体与雷达的物理中心，已知雷达原点相对于主体原点位移关系如下：x 0.2 y 0.0 z 0.5。当前雷达检测到一障碍物，在雷达坐标系中障碍物的坐标为(2.0 3.0 5.0)，请问，该障碍物相对于主体的坐标是多少？

<B>结果演示：</B>

<div align="center">
    <img src="./image/静态坐标变换_坐标系关系.png">
</div>


<B>实现分析：</B>

1. 坐标系相对关系，可以通过发布方发布
2. 订阅方，订阅到发布的坐标系相对关系，再传入坐标点信息(可以写死)，然后借助于tf实现坐标变换，并将结果输出。


<B>实现流程：</B>C++与Python实现流程一致

1. 新建功能包，添加依赖
2. 编写发布方实现
3. 编写订阅方实现
4. 执行并查看结果

---

方案A：C++实现

### 1. 创建功能包

创建项目功能包依赖于tf2、tf2_ros、tf2_geometry_msgs、roscpp、rospy、std_msgs、geometry_msgs

### 2. 发布方

```c++
#include "ros/ros.h"
#include "tf2_ros/static_transform_broadcaster.h"
#include "geometry_msgs/TransformStamped.h"
#include "tf2/LinearMath/Quaternion.h"

/**
 *  需求：发布两个坐标系的相对关系
 * 
 *  流程：
 *      1.包含头文件；
 *      2.设置编码 节点初始化 NodeHandle；
 *      3.创建发布对象；
 *      4.组织被发布的消息；
 *      5.发布数据。
 *      6.spin();
*/

int main(int argc, char *argv[])
{
    // 2.设置编码 节点初始化 NodeHandle；
    setlocale(LC_ALL, "");
    ros::init(argc, argv, "static_pub");
    ros::NodeHandle nh;

    // 3.创建发布对象；
    tf2_ros::StaticTransformBroadcaster pub;

    // 4.组织被发布的消息；
    geometry_msgs::TransformStamped tfs;
    tfs.header.stamp = ros::Time::now();    // 时间戳
    tfs.header.frame_id = "base_link";   // 相对坐标系关系中被参考的那一个
    tfs.child_frame_id = "laser";   //  相对坐标系参考的那一个
    tfs.transform.translation.x = 0.2;  // 相对坐标x
    tfs.transform.translation.y = 0.0;  // 相对坐标y
    tfs.transform.translation.z = 0.5;  // 相对坐标z
    // 需要根据欧拉角转换
    tf2::Quaternion qtn;    // 创建四元数 对象
    // 向该对象设置欧拉角，这个对象可以将欧拉角转换成四元数
    qtn.setRPY(0, 0, 0);    // 欧拉角的单位是弧度
    tfs.transform.rotation.x = qtn.getX();
    tfs.transform.rotation.y = qtn.getY();
    tfs.transform.rotation.z = qtn.getZ();
    tfs.transform.rotation.w = qtn.getW();

    // 5.发布数据；
    pub.sendTransform(tfs);
    // 6.spin();
    ros::spin();
    
    return 0;
}
```

### 3. 订阅方

```c++
#include "ros/ros.h"
#include "tf2_ros/transform_listener.h"
#include "tf2_ros/buffer.h"
#include "geometry_msgs/PointStamped.h"
#include "tf2_geometry_msgs/tf2_geometry_msgs.h"

/**
 *  订阅方：订阅发布的坐标系相对关系，传入一个坐标点，调用 tf 实现转换
 * 
 *  流程：
 *      1.包含头文件；
 *      2.编码、初始化、NodeHandle（必须的）
 *      3.创建订阅对象； ---> 订阅坐标系相对关系
 *      4.组织一个坐标点数据；
 *      5.转换算法，需要调用TF内置实现；
 *      6.最后输出。
*/

int main(int argc, char *argv[])
{
    // 2.编码、初始化、NodeHandle（必须的）
    setlocale(LC_ALL, "");
    ros::init(argc, argv, "static_sub");
    ros::NodeHandle nh;

    // 3.创建订阅对象； ---> 订阅坐标系相对关系
    // 3.1 创建一个 buffer 缓存
    tf2_ros::Buffer buffer;

    // 3.2 再创建监听对象(监听对象可以将订阅的数据存入buffer)
    tf2_ros::TransformListener listener(buffer);

    // 4.组织一个坐标点数据；
    geometry_msgs::PointStamped ps;
    ps.header.frame_id = "laser";
    ps.header.stamp = ros::Time::now();
    ps.point.x = 2.0;
    ps.point.y = 3.0;
    ps.point.z = 5.0;

    // 添加休眠
    // ros::Duration(1.0).sleep();
    // ROS_INFO("等待 1 秒后开始转换");

    // 5.转换算法，需要调用TF内置实现；
    ros::Rate rate(10.0);
    while (ros::ok())
    {
        // 核心代码实现 ---- 将 ps 转换成相对于 base_link 的坐标点
        geometry_msgs::PointStamped ps_out;
        /**
         *  调用了 buffer 的转换函数 transform
         *  参数1：被转换的坐标点
         *  参数2：目标坐标系
         *  返回值：输出的坐标点
         * 
         *  PS1：调用时必须包含头文件 tf2_geometry_msgs/tf2_geometry_msgs.h
         *  PS2：运行时存在的问题，抛出一个异常 base_link 不存在
         *      原因：订阅数据是一个耗时操作，可能在调用 transform 转换函数时，坐标系的相对关系还没有订阅到，因此出现异常
         *      解决：
         *          方案1：在调用转换函数前，执行休眠
         *          方案2：进行异常处理 (建议)
         *  
        */
        try
        {
            ps_out = buffer.transform(ps, "base_link");
            ROS_INFO("转换后的坐标值：(%.2f, %.2f, %.2f), 参考的坐标系：%s",
                    ps_out.point.x,
                    ps_out.point.y,
                    ps_out.point.z,
                    ps_out.header.frame_id.c_str()
                    );
        }
        catch(const std::exception& e)
        {
            ROS_INFO("异常消息：%s", e.what());
        }
        

        // 6.最后输出。
        rate.sleep();
        ros::spinOnce();
    }
    return 0;
}
```

### 4. 执行

可以使用命令行或launch文件的方式分别启动发布节点与订阅节点，如果程序无异常，控制台将输出转换后的坐标值。

---

方案B：Python实现


### 1. 创建功能包

### 2. 发布方

```python
#! /usr/bin/env python
import rospy
import tf2_ros
import tf # 欧拉角转换为四元数
from geometry_msgs.msg import TransformStamped

"""
    发布方：发布两个坐标系的相对关系（车辆底盘 --- base_link 和 雷达 --- laser）
    流程：
        1.导包；
        2.初始化节点；
        3.创建发布对象；
        4.组织被发布的数据；
        5.发布数据；
        6.spin()。
"""

if __name__ == "__main__":
    # 2.初始化节点；
    rospy.init_node("static_pub_p")

    # 3.创建发布对象；
    pub = tf2_ros.StaticTransformBroadcaster()

    # 4.组织被发布的数据；
    ts = TransformStamped()
    # header
    ts.header.stamp = rospy.Time.now()
    ts.header.frame_id = "base_link"
    # child frame
    ts.child_frame_id = "laser"
    # 相对关系（偏移 与 四元数）
    ts.transform.translation.x = 0.2
    ts.transform.translation.y = 0.0
    ts.transform.translation.z = 0.5
    # 4-1 先从欧拉角转换成四元数
    qtn = tf.transformations.quaternion_from_euler(0, 0, 0)
    # 4-2 再设置四元数
    ts.transform.rotation.x = qtn[0]
    ts.transform.rotation.y = qtn[1]
    ts.transform.rotation.z = qtn[2]
    ts.transform.rotation.w = qtn[3]

    # 5.发布数据；
    pub.sendTransform(ts)

    # 6.spin()。
    rospy.spin()
```

### 3. 订阅方

```python
#! /usr/bin/env python

import rospy
import tf2_ros
from tf2_geometry_msgs import tf2_geometry_msgs # 不可以使用 geometry_msgs.msg中的类型


"""
    订阅方：订阅坐标变换消息，传入被转换的坐标点，调用转换算法

    流程：
        1.导包；
        2.初始化；
        3.创建订阅对象；
        4.组织被转换的坐标点；
        5.转换逻辑实现，调用tf封装的算法；
        6.输出结果；
        7.spin() | spinOnce();
"""

if __name__ == "__main__":
    # 2.初始化；
    rospy.init_node("static_sub_p")

    # 3.创建订阅对象；
    # 3-1 创建缓存对象
    buffer = tf2_ros.Buffer()
    # 3-2 创建订阅对象（将缓存传入）
    sub = tf2_ros.TransformListener(buffer)

    # 4.组织被转换的坐标点；
    # 4-1 创建一个坐标点
    ps = tf2_geometry_msgs.PointStamped()
    ps.header.frame_id = "laser"
    ps.header.stamp = rospy.Time(0)
    ps.point.x = 2.0
    ps.point.y = 3.0
    ps.point.z = 5.0

    # 5.转换逻辑实现，调用tf封装的算法；
    rate = rospy.Rate(10)
    while not rospy.is_shutdown():
        try:
            # 转换实现
            """
                参数1：被转换的坐标点
                参数2：目标坐标系
                返回值：转换后的坐标点

                PS：
                问题：抛出异常 base_link 不存在
                原因：转换函数调用时，可能还没有订阅到坐标系的相对信息
                解决：try 捕获异常，并处理
            """
            ps_out = buffer.transform(ps, "base_link")
            rospy.loginfo("转换后的坐标：(%.2f, %.2f, %.2f), 参考的坐标系：%s",
                          ps_out.point.x,
                          ps_out.point.y,
                          ps_out.point.z,
                          ps_out.header.frame_id)
        except Exception as e:
            rospy.loginfo("坐标转换失败！")
            rospy.logwarn("错误提示：" + str(e))
        
        rate.sleep()

    # 6.输出结果；
    # 7.spin() | spinOnce();
```

PS: 在 tf2 的 python 实现中，tf2 已经封装了一些消息类型，不可以使用 geometry_msgs.msg 中的类型

### 4. 执行

可以使用命令行或launch文件的方式分别启动发布节点与订阅节点，如果程序无异常，控制台将输出，坐标转换后的结果。

---

<B>补充1：</B>

当坐标系之间的相对位置固定时，那么所需参数也是固定的：父系坐标名称、子级坐标系名称、x偏移量、y偏移量、z偏移量、x翻滚角度、y俯仰角度、z偏航角度，实现逻辑相同，参数不同，那么ROS已经封装好了专门的节点，使用方式如下：

```bash
rosrun tf2_ros static_transform_publisher x偏移量 y偏移量 z偏移量 z偏航角度 y俯仰角度 x翻滚角度 父系坐标系 子级坐标系
```

示例：`rosrun tf2_ros static_transform_publisher 0.2 0 0.5 0 0 0 /base_link /laser`

也建议使用该种方式直接实现静态坐标系相对信息发布。



<B>补充2：</B>

可以借助于rviz显示坐标系关系，具体操作：

- 新建窗口输入命令：rviz;
- 在启动的rviz中设置Fixed Frame 为base_link;
- 点击左下的add按钮，在弹出的窗口中选择 TF 组件，即可显示坐标关系。

---



## 5.1.3 动态坐标变换

所谓动态坐标变换，是指两个坐标系之间的相对位置是变化的。

<B>需求描述：</B>

启动`turtlesim_node`，该节点中窗体有一个世界坐标系(左下角为坐标系圆点)，乌龟是另一个坐标系，键盘控制乌龟运动，将两个坐标系的相对位置动态发布。

<B>结果演示：</B>

<div align=center>
    <img src="./image/坐标变换_动态.gif" />
</div>


<B>实现分析：</B>

1. 乌龟本身不但可以看作坐标系，也是世界坐标系中的一个坐标点；
2. 订阅`turtle1/pose`，可以获取乌龟在世界坐标系的x坐标、y坐标、偏移量以及线速度和角速度；
3. 将pose信息转换成坐标系相对信息并发布。


<B>实现流程：</B>C++与Python实现流程一致

1. 新建功能包，添加依赖；
2. 创建坐标相对关系发布方(同时需要订阅乌龟位姿信息)；
3. 创建坐标相对关系订阅方；
4. 执行

---
### 方案A:C++实现


#### 1. 创建功能包

创建项目功能包依赖于tf2、tf2_ros、tf2_geometry_msgs、roscpp、rospy、std_msgs、geometry_msgs、turtlesim

#### 2. 发布方

1. 准备工作：

```bash
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter5/demo06_ws$ rostopic list
/turtle1/pose       # 话题名称
fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter5/demo06_ws$ rostopic info /turtle1/pose 
Type: turtlesim/Pose    # 使用的消息

Publishers: 
 * /turtlesim (http://fgs-MS-7D17:45051/)

Subscribers: None


fgs@fgs-MS-7D17:~/Workstations/ROS/Chapter5/demo06_ws$ rosmsg info turtlesim/Pose  # 消息详情
float32 x
float32 y
float32 theta
float32 linear_velocity
float32 angular_velocity
```

```cpp
#include "ros/ros.h"
#include "turtlesim/Pose.h"
#include "tf2_ros/transform_broadcaster.h"
#include "geometry_msgs/TransformStamped.h"
#include "tf2/LinearMath/Quaternion.h"

/**
 *  发布方：需要订阅乌龟的位姿信息，再转换成相对窗体的坐标关系，并发布
 *  准  备：
 *      话题：/turtle1/pose 
 *      消息：turtlesim/Pose
 * 
 *  流程：
 *      1.包含头文件；
 *      2.设置编码、初始化、NodeHandle;
 *      3.创建订阅对象，订阅 /turtle1/pose;
 *      4.回调函数处理订阅的消息：将位姿信息转换成坐标相对关系并发布(关注)
 *      5.spin()
*/

void doPose(const turtlesim::Pose::ConstPtr &pose) {
    // 1.获取位姿信息
    // a. 创建发布对象；
    static tf2_ros::TransformBroadcaster pub;
    // b. 组织被发布的数据
    geometry_msgs::TransformStamped ts;
    ts.header.frame_id = "world";
    ts.header.stamp = ros::Time::now();
    ts.child_frame_id = "turtle1";
    ts.transform.translation.x = pose->x;
    ts.transform.translation.y = pose->y;
    ts.transform.translation.z = 0;
    // 坐标系四元数
    /**
     *  位姿信息中没有四元数，但是有个偏航角度，又已知乌龟是2D，没有翻滚与俯仰角度，所以可以得出乌龟的欧拉角：0， 0， theta
    */
    tf2::Quaternion qtn;
    qtn.setRPY(0, 0, pose->theta);

    ts.transform.rotation.x = qtn.getX();
    ts.transform.rotation.y = qtn.getY();
    ts.transform.rotation.z = qtn.getZ();
    ts.transform.rotation.w = qtn.getW();

    // 2.转换成相对坐标(核心)
    // 3.发布坐标信息
    pub.sendTransform(ts);
}

int main(int argc, char *argv[])
{
    // 2.设置编码、初始化、NodeHandle;
    setlocale(LC_ALL, "");
    ros::init(argc, argv, "dynamic_pub");
    ros::NodeHandle nh;

    // 3.创建订阅对象，订阅 /turtle1/pose;
    ros::Subscriber sub = nh.subscribe("/turtle1/pose", 10, doPose);

    // 4.回调函数处理订阅的消息：将位姿信息转换成坐标相对关系并发布(关注)
    // 5.spin()
    ros::spin();
    return 0;
}
```


#### 3. 订阅方

```cpp
#include "ros/ros.h"
#include "tf2_ros/transform_listener.h"
#include "tf2_ros/buffer.h"
#include "geometry_msgs/PointStamped.h"
#include "tf2_geometry_msgs/tf2_geometry_msgs.h"

/**
 *  订阅方：订阅发布的坐标系相对关系，传入一个坐标点，调用 tf 实现转换
 * 
 *  流程：
 *      1.包含头文件；
 *      2.编码、初始化、NodeHandle（必须的）
 *      3.创建订阅对象； ---> 订阅坐标系相对关系
 *      4.组织一个坐标点数据；
 *      5.转换算法，需要调用TF内置实现；
 *      6.最后输出。
*/

int main(int argc, char *argv[])
{
    // 2.编码、初始化、NodeHandle（必须的）
    setlocale(LC_ALL, "");
    ros::init(argc, argv, "dynamic_sub");
    ros::NodeHandle nh;

    // 3.创建订阅对象； ---> 订阅坐标系相对关系
    // 3.1 创建一个 buffer 缓存
    tf2_ros::Buffer buffer;

    // 3.2 再创建监听对象(监听对象可以将订阅的数据存入buffer)
    tf2_ros::TransformListener listener(buffer);

    // 4.组织一个坐标点数据；
    geometry_msgs::PointStamped ps;
    // 参考的坐标系
    ps.header.frame_id = "turtle1";
    // ps.header.stamp = ros::Time::now();
    ps.header.stamp = ros::Time(0.0);
    ps.point.x = 2.0;
    ps.point.y = 3.0;
    ps.point.z = 5.0;

    // 添加休眠
    // ros::Duration(1.0).sleep();
    // ROS_INFO("等待 1 秒后开始转换");

    // 5.转换算法，需要调用TF内置实现；
    ros::Rate rate(10.0);
    while (ros::ok())
    {
        // 核心代码实现 ---- 将 ps 转换成相对于 base_link 的坐标点
        geometry_msgs::PointStamped ps_out;
        /**
         *  调用了 buffer 的转换函数 transform
         *  参数1：被转换的坐标点
         *  参数2：目标坐标系
         *  返回值：输出的坐标点
         * 
         *  PS1：调用时必须包含头文件 tf2_geometry_msgs/tf2_geometry_msgs.h
         *  PS2：运行时存在的问题，抛出一个异常 base_link 不存在
         *      原因：订阅数据是一个耗时操作，可能在调用 transform 转换函数时，坐标系的相对关系还没有订阅到，因此出现异常
         *      解决：
         *          方案1：在调用转换函数前，执行休眠
         *          方案2：进行异常处理 (建议)
         *  
        */
        try
        {
            ps_out = buffer.transform(ps, "world");
            ROS_INFO("转换后的坐标值：(%.2f, %.2f, %.2f), 参考的坐标系：%s",
                    ps_out.point.x,
                    ps_out.point.y,
                    ps_out.point.z,
                    ps_out.header.frame_id.c_str()
                    );
        }
        catch(const std::exception& e)
        {
            ROS_INFO("异常消息：%s", e.what());
        }
        

        // 6.最后输出。
        rate.sleep();
        ros::spinOnce();
    }
    return 0;
}
```

<B>注意：</B>在订阅方中，`ps.header.stamp`设置为`ros::Time(0.0);`，而不是`ros::Time::now();`因为，如果使用`ros::Time::now();`会得到一个与发送的数据相比较晚的时间戳，如果时间戳相差太大，则ros不会为其进行转换。报错信息如下：

```bash
Lookup would require extrapolation 0.241493721s into the past.  Requested time 1693322521.056759596 but the earliest data is at time 1693322521.298253536, when looking up transform from frame [turtle1] to frame [world]
```

#### 4. 执行

可以使用命令行或launch文件的方式分别启动发布节点与订阅节点，如果程序无异常，与演示结果类似。

可以使用 rviz 查看坐标系相对关系。

---

### 方案B:Python实现

#### 1. 创建功能包

创建项目功能包依赖于tf2、tf2_ros、tf2_geometry_msgs、roscpp、rospy、std_msgs、geometry_msgs、turtlesim。

#### 2. 发布方

```python
#! /usr/bin/env python

import rospy
from turtlesim.msg import Pose
import tf2_ros
from geometry_msgs.msg import TransformStamped
import tf

"""
    发布方：订阅乌龟的位姿信息，转换成坐标系的相对关系，再发布
    准  备：
        话题：/turtle1/pose
        类型：/turtlesim/Pose

    流  程：
        1.导包；
        2.初始化ROS节点；
        3.创建订阅对象；
        4.回调函数处理订阅到的消息(核心);
        5.spin().
"""

def doPose(pose):
    # 1.创建发布坐标系相对关系的对象
    pub = tf2_ros.TransformBroadcaster()

    # 2.将 pose 转换成 坐标系相对关系信息
    ts = TransformStamped()
    ts.header.frame_id = "world"
    ts.header.stamp = rospy.Time.now()
    ts.child_frame_id = "turtle1"

    # 子级坐标系相对于父级坐标系的偏移量
    ts.transform.translation.x = pose.x
    ts.transform.translation.y = pose.y
    ts.transform.translation.z = 0.0

    # 四元数
    # 从 欧拉角 转换四元数
    """
        乌龟是2D，不存在 X 上的翻滚，Y上的俯仰，只有 Z 上的偏航
    """
    qtn = tf.transformations.quaternion_from_euler(0, 0, pose.theta)
    ts.transform.rotation.x = qtn[0]
    ts.transform.rotation.y = qtn[1]
    ts.transform.rotation.z = qtn[2]
    ts.transform.rotation.w = qtn[3]

    # 3.发布坐标系相对关系信息
    pub.sendTransform(ts)

if __name__ == "__main__":
    # 2.初始化ROS节点；
    rospy.init_node("dynamic_pub_p")

    # 3.创建订阅对象；
    sub = rospy.Subscriber("/turtle1/pose", Pose, doPose, queue_size=100)

    # 4.回调函数处理订阅到的消息(核心);
    # 5.spin().
    rospy.spin()
```

#### 3. 订阅方

```python
#! /usr/bin/env python

import rospy
import tf2_ros
from tf2_geometry_msgs import tf2_geometry_msgs 


"""
    订阅方：订阅坐标变换消息，传入被转换的坐标点，调用转换算法

    流程：
        1.导包；
        2.初始化；
        3.创建订阅对象；
        4.组织被转换的坐标点；
        5.转换逻辑实现，调用tf封装的算法；
        6.输出结果；
        7.spin() | spinOnce();
"""

if __name__ == "__main__":
    # 2.初始化；
    rospy.init_node("dynamic_sub_p")

    # 3.创建订阅对象；
    # 3-1 创建缓存对象
    buffer = tf2_ros.Buffer()
    # 3-2 创建订阅对象（将缓存传入）
    sub = tf2_ros.TransformListener(buffer)

    # 4.组织被转换的坐标点；
    # 4-1 创建一个坐标点
    ps = tf2_geometry_msgs.PointStamped()
    ps.header.frame_id = "turtle1"
    # 时间戳 -- 0
    ps.header.stamp = rospy.Time(0)
    ps.point.x = 2.0
    ps.point.y = 3.0
    ps.point.z = 5.0

    # 5.转换逻辑实现，调用tf封装的算法；
    rate = rospy.Rate(10)
    while not rospy.is_shutdown():
        try:
            # 转换实现
            """
                参数1：被转换的坐标点
                参数2：目标坐标系
                返回值：转换后的坐标点

                PS：
                问题：抛出异常 base_link 不存在
                原因：转换函数调用时，可能还没有订阅到坐标系的相对信息
                解决：try 捕获异常，并处理
            """
            ps_out = buffer.transform(ps, "world")
            rospy.loginfo("转换后的坐标：(%.2f, %.2f, %.2f), 参考的坐标系：%s",
                          ps_out.point.x,
                          ps_out.point.y,
                          ps_out.point.z,
                          ps_out.header.frame_id)
        except Exception as e:
            rospy.loginfo("坐标转换失败！")
            rospy.logwarn("错误提示：" + str(e))
        
        rate.sleep()

    # 6.输出结果；
    # 7.spin() | spinOnce();
```

#### 4. 执行

可以使用命令行或launch文件的方式分别启动发布节点与订阅节点，如果程序无异常，与演示结果类似。

可以使用 rviz 查看坐标系相对关系。

## 5.1.4 多坐标变换

<B>需求描述：</B>

现有坐标系统，父级坐标系统world下有两个子坐标系，son1与son2，son1相对于world，以及son2相对于world的关系是已知的，求son1原点在son2中的坐标，又已知在son1中一点的坐标，要求求出该点在son2中的坐标。

<B>实现分析：</B>

1. 首先，需要发布son1相对于world，以及son2相对于world的坐标消息；
2. 然后，需要订阅坐标发布消息，并取出订阅的消息，借助于tf2实现son1和son2的转换；
3. 最后，还要实现坐标点的转换。


<B>实现流程:</B>C++ 与 Python 实现流程一致

1. 新建功能包，添加依赖
2. 创建坐标相对关系发布方(同时需要订阅乌龟位姿信息)
3. 创建坐标相对关系订阅方
4. 执行

---

#### 方案A:C++实现

##### 1.创建功能包

创建项目功能包依赖于 tf2、tf2_ros、tf2_geometry_msgs、roscpp rospy std_msgs geometry_msgs

##### 2.发布方

```launch
<launch>
    <node pkg="tf2_ros" type="static_transform_publisher" name="son1" args="0.2 0.8 0.3 0 0 0 /world /son1" output="screen" />
    <node pkg="tf2_ros" type="static_transform_publisher" name="son2" args="0.5 0 0 0 0 0 /world /son2" output="screen" />
</launch>
```

##### 3.订阅方

```cpp
#include "ros/ros.h"
#include "tf2_ros/transform_listener.h" // 创建订阅对象所需的库
#include "tf2_ros/buffer.h" // 创建buffer所需的头文件
#include "geometry_msgs/PointStamped.h" // 创建坐标系消息所需的头文件
#include "tf2_geometry_msgs/tf2_geometry_msgs.h" // 创建消息所需的头文件
#include "geometry_msgs/TransformStamped.h"

/**
 *  订阅方实现：1.计算son1与son2的相对关系 2.计算son1中的某个坐标点在 son2 中的坐标值
 * 
 *  流程：
 *      1.包含头文件；
 *      2.编码、初始化、NodeHandle；
 *      3.创建订阅对象；
 *      4.编写解析逻辑；
 *      5.spinOnce();
*/

int main(int argc, char *argv[])
{
    // 2.编码、初始化、NodeHandle；
    setlocale(LC_ALL,"");
    ros::init(argc,argv,"tfs_sub");
    ros::NodeHandle nh;

    // 3.创建订阅对象；
    tf2_ros::Buffer buffer;
    tf2_ros::TransformListener sub(buffer);

    // 4.编写解析逻辑；

    // 创建坐标点
    geometry_msgs::PointStamped psAtSon1;
    
    psAtSon1.header.stamp = ros::Time::now();
    psAtSon1.header.frame_id = "son1";
    psAtSon1.point.x = 1.0;
    psAtSon1.point.y = 2.0;
    psAtSon1.point.z = 3.0;

    ros::Rate rate(10.0);
    while(ros::ok()) {
        // 核心
        try
        {
            // 1.计算son1与son2的相对关系
            geometry_msgs::TransformStamped son1Toson2 = buffer.lookupTransform("son2", "son1", ros::Time(0));
            ROS_INFO("son1 相对于 son2 的信息：父级：%s, 子级：%s", son1Toson2.header.frame_id.c_str(), son1Toson2.child_frame_id.c_str());
            ROS_INFO("son1与son2的相对关系：%.2f, %.2f, %.2f", son1Toson2.transform.translation.x, son1Toson2.transform.translation.y, son1Toson2.transform.translation.z);


            // 2.计算son1中的某个坐标点在 son2 中的坐标值
            geometry_msgs::PointStamped psAtSon2 = buffer.transform(psAtSon1, "son2");
            ROS_INFO("son1中的坐标点在son2中的坐标值：%.2f, %.2f, %.2f", psAtSon2.point.x, psAtSon2.point.y, psAtSon2.point.z);
        }
        catch(const std::exception& e)
        {
            ROS_INFO("错误提示：%s", e.what());
        }
        

        rate.sleep();
        ros::spinOnce();
    }
    // 5.spinOnce();
    return 0;
}
```

##### 4.执行

可以使用命令行或launch文件的方式分别启动发布节点与订阅节点，如果程序无异常，将输出换算后的结果。

---


#### 方案B:Python实现

##### 1.创建功能包

创建项目功能包依赖于 tf2、tf2_ros、tf2_geometry_msgs、roscpp、rospy、std_msgs、geometry_msgs

##### 2.发布方

```launch
<launch>
    <node pkg="tf2_ros" type="static_transform_publisher" name="son1" args="0.2 0.8 0.3 0 0 0 /world /son1" output="screen" />
    <node pkg="tf2_ros" type="static_transform_publisher" name="son2" args="0.5 0 0 0 0 0 /world /son2" output="screen" />
</launch>
```

##### 3.订阅方

```python
#! /usr/bin/env python

import rospy
import tf2_ros
from tf2_geometry_msgs import tf2_geometry_msgs
from geometry_msgs.msg import TransformStamped

if __name__ == "__main__":
    # 2. 初始化
    rospy.init_node("tfs_sub_p")

    # 3. 创建订阅对象
    # 3.1 创建缓存对象
    buffer = tf2_ros.Buffer()
    # 3.2 创建订阅对象(将缓存传入)
    sub = tf2_ros.TransformListener(buffer)

    # 4. 组织被转换的坐标点
    ps = tf2_geometry_msgs.PointStamped()
    # ps.header.stamp = rospy.Time()
    ps.header.stamp = rospy.Time.now() # 因为使用的是静态坐标，所以用 now() 也可以
    ps.header.frame_id = "son1"
    ps.point.x = 1.0
    ps.point.y = 2.0
    ps.point.z = 3.0

    # 5. 转换逻辑实现，调用 tf 封装的算法：
    rate = rospy.Rate(10)
    while not rospy.is_shutdown():
        try:
            # ----------- 计算 son1 相对于 son2 的坐标系
            """
                参数1：目标坐标系
                参数2：源坐标系
                参数3：rospy.Time(0) --- 取时间间隔最近的两个帧(son1 相对 world 与 son2 相对 world)计算结果
            """
            ts = buffer.lookup_transform("son2", "son1", rospy.Time(0))
            rospy.loginfo("父级坐标系: %s，子级坐标系：%s", ts.header.frame_id, ts.child_frame_id)
            rospy.loginfo("相对坐标系关系：%.2f, %.2f, %.2f", ts.transform.translation.x, ts.transform.translation.y, ts.transform.translation.z)

            # 转换实现
            ps_out = buffer.transform(ps, "son2")
            rospy.loginfo("转换后的坐标系：%s", ps_out.header.frame_id)
            rospy.loginfo("转换后的坐标：%.2f, %.2f, %.2f", ps_out.point.x, ps_out.point.y, ps_out.point.z)

        except Exception as e:
            rospy.logerr(e)
        rate.sleep()
```

##### 4.执行